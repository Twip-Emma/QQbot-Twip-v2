{
    "Redis": [
        "什么是Redis-3",
        "说说Redis的基本数据结构类型（5种）-3",
        "谈谈为什么Redis这么快-4",
        "什么是缓存击穿、缓存穿透、缓存雪崩-4",
        "如何避免缓存击穿、缓存穿透、缓存雪崩-4",
        "什么是热点key，如何解决-6",
        "谈谈Redis的三种过期策略-6",
        "说说Redis的常用场景-7",
        "Redis的两种持久化策略，说说优缺点-9",
        "如何实现Redis的高可用-10",
        "谈谈Redis分布式锁-12",
        "说说Redisson的原理-12",
        "什么是Redlock算法-13",
        "说说Redis的跳跃表-13",
        "分别说说什么是Redis主从模式、哨兵模式、集群模式-10",
        "MySQL与Redis如何保证双写一致性（3种）-14",
        "为什么Redis6之后使用多线程了-15",
        "谈谈Redis事务机制-15",
        "Redis的哈希冲突怎么办-15",
        "什么是哈希冲突-16",
        "在生成RDB期间，Redis可以同时处理写请求吗-16",
        "Redis底层用的什么协议-16",
        "谈谈布隆过滤器-16"
    ],
    "消息队列": [
        "RabbitMQ是什么-18",
        "RabbitMQ的特点有哪些-18",
        "说说什么是生产者和消费者-18",
        "为什么要用消息队列-18",
        "说说服务节点Broker、队列Queue、交换机Exchange-18",
        "消息队列有什么优缺点-18",
        "如何保证消息队列的可靠性-19",
        "什么是RoutingKey路由键-19",
        "什么是Binding绑定-19",
        "RabbitMQ交换机的四种类型-20",
        "谈谈生产者消息运转-20",
        "谈谈消费者接受消息的过程-20",
        "交换机无法根据自身类型和路由键找到符合条件队列时，有哪些处理方式-21",
        "什么是死信队列-21",
        "导致死信的几种原因-21",
        "什么是延迟队列-21",
        "什么是优先级队列-21",
        "消息队列的事务机制-21",
        "谈谈发送确认机制-21",
        "谈谈消息队列的使用场景-22",
        "生产者如何将消息可靠投递到消息队列-22",
        "消息队列如何可靠投递消息给消费者-22",
        "如何保证消息队列的高可用-22"
    ],
    "服务注册与发现": [
        "Nacos的服务注册表结构是什么样的-23",
        "Nacos如何支撑数十万服务的注册压力的-23",
        "Nacos如何避免读写冲突问题-23",
        "Nacos和Eureka的区别有哪些-23",
        "为什么要将服务注册到Nacos-24",
        "Nacos是如何判断服务实例状态的-24",
        "谈谈Nacos中的负载均衡底层是如何实现的-24",
        "服务消费方是如何调用服务提供方的服务的-24"
    ],
    "SpringCloud微服务架构": [
        "什么是微服务架构-24",
        "谈谈SpringCloud的优缺点-25",
        "SpringCloud是什么-24",
        "谈谈SpringBoot和SpringCloud的区别-25",
        "SpringCloud由什么组成-25",
        "使用SpringCloud时，我们可能会碰见什么问题-25",
        "什么是Feign-26",
        "SpringCloud有哪些调用接口的方式（2种）-26",
        "Ribbon和Feign调用服务的区别-26",
        "什么是Gateway-26",
        "什么是OpenFeign-26",
        "谈谈消息队列保证高可用的三种方式-26",
        "如何保证消息消费的幂等性-27"
    ],
    "多线程": [
        "线程与进程的区别",
        "什么是线程中的上下文的切换",
        "什么是死锁活锁-28",
        "饥饿与死锁的区别-28",
        "Java中守护线程和本地线程的区别-29",
        "为什么使用Executor框架-29",
        "在Java中Executor和Executors的区别-29",
        "Java中用到的线程调度算法是什么-29",
        "什么是线程组，为什么在Java中不推荐用-30",
        "什么是Callable和Future-30",
        "什么是FutureTask-30",
        "什么是并发容器的实现-30",
        "多线程同步和互斥有几种实现的方法，都是什么-30",
        "什么是不可变对象，他对于并发应用有什么帮助-31",
        "什么是多线程中的上下文切换-31",
        "notify()和notifyAll()的区别-32",
        "什么是Daemon线程，他有什么意义-32",
        "Java如何实现多线程之间的通讯和协作-32",
        "什么是线程安全-32",
        "Servlet线程安全吗-32",
        "SpringMVC中的Controller线程安全吗-32",
        "volatole关键字有什么用，谈谈其应用场景-32",
        "为什么代码会重排序-33",
        "Java中wait和sleep方法的不同是什么-33",
        "什么是线程池，为什么要用它-33",
        "如何检测一个线程是否有锁-33",
        "如何在Java中获取线程堆栈-33",
        "JVM中哪个参数是用来控制线程的堆栈大小的-33",
        "Thread类中的yield方法有什么用-33",
        "Java中ConcurrentHashMap的并发度是什么-34",
        "Java中Semaphore是什么-34",
        "Java中线程池submit()和execute()方法有什么区别-34",
        "什么是阻塞式方法-34",
        "Java中的ReadWriteLock是什么-34",
        "volatile变量和atomic变量有什么不同-34",
        "同步方法和同步块哪个是更好的选择-34",
        "Java的Timer类是什么，如何创建一个有特定时间间隔的任务-35",
        "Java如何创建守护线程-35",
        "Java中如何唤醒一个阻塞的线程-35",
        "为什么要并发编程-35",
        "谈谈多线程的应用场景-35",
        "并发编程的特点-35",
        "并发编程的三个必要因素是什么-35",
        "守护线程和用户线程有什么区别-36",
        "形成四锁的四个必要条件是什么-36"
    ]
}